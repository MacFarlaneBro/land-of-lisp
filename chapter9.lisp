(make-array 3)

;; In order to differentiate an array from a list the repl will prepend a hash mark '#' to it.

(defparameter x (make-array 3))
(aref x 1)


;; Return multiple values

(defun foo ()
  (values 3 7))

(foo)
;; => 3, 7

;; However by default only the first returned value is used in future calculations

;; Capturing multiple return values

(multiple-value-bind (a b) (foo)
  (+ a b))
;; => 10

;; Creating a hash table

(defparameter x (make-hash-table))

;; setf can be used to set values inside datastructures such as arrays or hashmaps
(setf (gethash 'moonpie x) 'penny-whistle)

(gethash 'moonpie x)

(load "chapter8")

(setf *edge-num* 1000)
(setf *node-num* 1000)

;; The time command does exactly what you would expect it to
(time (dotimes (i 100) (get-connected 1 (make-edge-list))))

(defun hash-edges (edge-list)
  ;; Create a new hash table
  (let ((tab (make-hash-table)))
    ;; For each edge in edge list
    (mapc (lambda (x)
	    ;; Assign node number of current node to 'node'
	    (let ((node (car x)))
	      ;; Add the node list to the hash table as value with the node number as key
	      (push (cdr x) (gethash node tab))))
	  edge-list)
    ;; Return the filled hash table
    tab))

(defun get-connected-hash (node edge-tab)
  ;; Creaate a new hash table
  (let ((visited (make-hash-table)))
    ;; Define function traverse
    (labels ((traverse (node)
	       ;; If the node has not yet been visited
	       (unless (gethash node visited)
		 ;; Set the node to visited
		 (setf (gethash node visited) t)
		 ;; For each edge attached to the node
		 (mapc (lambda (edge)
			 ;; Traverse the edge
			 (traverse edge))
		       ;; get the list of edges attached to the current node
		       (gethash node edge-tab)))))
      ;; Start traversing the nodes
      (traverse node))
    ;; return a list of the visited nodes
    visited))

(time (dotimes (i 100)
	(get-connected-hash 1 (hash-edges (make-edge-list)))))

;; Common lisp structures

;; Define a structure called 'person' which has 4 properties (also known as slots in the lisp community).
(defstruct person
  name
  age
  waist-size
  favorite-color)

;;  We can now create instances of this person using the 'make-person' command, a function automatically created by the defstruct command
(defparameter *bob* (make-person :name "Bob"
				 :age 35
				 :waist-size 32
				 :favorite-color "Blue"))

;; In addition to the autogenerated 'make' function, several other functions are autogenerated by defstruct, including accessors for each of the fields
(person-age *bob*)
(person-waist-size *bob*)

;; Which can, of course, also be used for mutation
(setf (person-age *bob*) 25)

;; The lisp reader can even create a person directly from the printed representation of that person

(defparameter *that-guy* #S(person :name "Bob" :age "35" :waist-size 32 :favorite-color "blue"))

(person-age *that-guy*)

;; Although structs such as these are potentially useful, they're also anathema to functional purists and all that can be achieved with structs can also be achieved in a pure form using lists

(defun make-person (name age waist-size favorite-color)
  (list name age waist-size favorite-color))

(defun person-age (person)
  (cadr person))

(defun person-waist-size (person)
  (caddr person))

(defparameter *bob* (make-person "bob" 35 32 "blue"))

*bob*

(person-age *bob*)

(person-waist-size *bob*)

;; Sequence functions - generic functions which work on any sequence

(length '(a b c))
(length "blub")
(length (make-array 5))

;; Searching sequences

;; Find the first number
(find-if #'numberp '(a b 5 d))

;; Count the number of 's' characters
(count #\s "mississippi")

;; Get the index of the '4' character
(position #\4 "2kewl4skewl")

;; Determine if the sequence contains a number
(some #'numberp '(a b 5 d))

;; Determine if the sequence contains only numbers
(every #'numberp '(a b 5 d))

;; Sum a list of numbers
(reduce #'+ '(3 4 6 5 2))

;; Find the largest even number in the list
(reduce (lambda (best item)
	  ;; If the current item is even and greater than the current greatest
	  (if (and (evenp item) (> item best))
	      ;; Return the current iteration item
	      item
	      ;; return the current best item
	      best))
	'(7 4 6 5 2)
	;; Use an initial value of 0
	:initial-value 0)

;; Generic sum function for sequences
(defun sum (lst)
  (reduce #'+ lst))

(sum '(1 2 3))

(sum (make-array 5 :initial-contents '(1 2 3 4 5)))

(sum "blablabla")

;; Capitalise 's' characters
(map
 ;; Return the result as a list
 'list
 (lambda (x)
   (if (eq x #\s)
       #\S
       x))
 "this is a string")

(subseq "america" 2 6)

(sort '(5 8 2 4 9 3 6) #'<)
